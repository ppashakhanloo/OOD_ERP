\newgeometry{left=4cm,right=4cm}

\chapter{الگوهای طراحی اعمال شده}

\section{Factory}
این الگو زمانی استفاده می‌شود که قصد داریم بدون اینکه به استفاده‌کننده اعلام کنیم چگونه یک شئ را می‌سازیم، شئ را ساخته و به وی تحویل دهیم. ما از این الگو در کلاس AccessLevel استفاده کرده‌ایم. استفاده به این صورت است که یک کلاس انتزاعی
\LTRfootnote{abstract}
 به نام AccessLevel داریم که سه زیرکلاس آن را پیاده‌سازی می‌کنند. هر کدام از این سه کلاس، نمایانگر یک نوع از سطح دسترسی هستند. حال یک AccessLevelFactory داریم که با توجه به کاربر،‌ و از طریق تابع getAccessLevel() یک AccessLevel تحویل استفاده‌کننده می‌دهد.\\
 به جای این الگو، امکان استفاده از الگوهای Creational دیگر چون 
 \lr{Abstract Factory}
 شاید به نظر برسد که قابل استفاده باشد. در حالی که چنین نیست. الگوی
 \lr{Abstract Factory}
 در نقش واسطی است که به استفاده‌کننده اجازه می‌دهد از طریق یک Factory خاص، یک Product خاص تحویل بگیرد که در زمانی کاربرد دارد که چند Factory داشته باشیم. حال آنکه در مورد استفاده‌ی ما، تنها یک Factory موجود است.


\section{Singleton}
این الگو زمانی استفاده می‌شود که دقیقا یک نمونه از یک کلاس لازم باشد. کلاس‌های Catalogue که در لایه‌ی منطق قرار دارند و همچنین کلاس‌های DAO که در لایه‌ی ارتباط با پایگاه‌داده قرار دارند، همگی از این الگو پیروی می‌کنند. این الگو، در مقابل استفاده از متد‌های ایستا در اینگونه کلاس‌ها استفاده شده است. چرا که استفاده از کلاس در طراحی شئ‌گرا تنها به عنوان قالب قابل قبول است؛ و نه به عنوان یک موجودیت که به طور مستقل کاری انجام می‌دهد.


\section{Observer}
این الگو زمانی استفاده می‌شود که تغییر در یک شئ، لازم است که به اطلاع اشیای دیگری برسد. ما از این الگو در واسط کاربری استفاده کرده‌ایم. این سناریو را در نظر بگیرید: یک پنجره  A پروژه‌های موجود در سازمان را نشان می‌دهد. حال پنجره‌ی دیگری باز می‌شود تا در آن بتوان یک پروژه‌ی جدید اضافه کرد. پس از افزوده شدن پروژه جدید، باید بلافاصله در پنجره A پروژه‌ی جدید هم نمایش داده شود. هر هنگام که چنین سناریویی پیش می‌آید، از الگوی Observer استفاده می‌نماییم. (به عنوان نمونه‌ی دقیق‌تر، در کلاس‌های EditProject و ViewProjects) در مواردی که محتویاتی که لازم است روی صفحه نمایش داده شود زیاد است، با update کردن تنها بخش تغییر یافته را بهنگام‌سازی می‌کنیم و در نتیجه سرعت نیز بالا می‌رود.



\section{Façade}
این الگو زمانی استفاده می‌شود که بخواهیم یک واسط یکپارچه برای چند واسط سیستم ایجاد کنیم. بر روی لایه‌ی منطق، سه Façade تعریف شده است که عبارتند از: OperationFacade ،‌ UserFacade و ProjectFacade . هرکدام از این سه، واسط بخشی از کلاس‌های لایه‌ی منطق هستند. لایه‌ی نمایش، که شامل JFrame‌ ها و JDialog ها است، هیچ ارتباط مستقیمی با کلاس‌های لایه‌ی منطق ندارد. به عبارت دیگر، این سه Façade تعریف شده، واسطی بین لایه‌ی منطق و لایه‌ی نمایش محسوب می‌گردد. هر کدام از Façade ها، با تعدادی از کلاس‌های منطق در ارتباط هستند.\\
به طور دقیق‌تر، نقش هریک از  Façade ها عبارت است از:
\begin{itemize}
\item
کلاس OperationFacade ، با کلاس‌های مربوط به منابع در ارتباط است و امکانات مربوط به دریافت و بهنگام‌سازی منابع را بر عهده دارد.
\item
کلاس ProjectFacade ، با کلاس‌های مربوط به پروژه (و در ننیجه سیستم و ماژول) در ارتباط است و امکانات مربوط به دریافت و بهنگام‌سازی این موارد را بر عهده دارد.
\item
کلاس UserFacade ، موارد کاربری را بر عهده دارد؛ به این صورت که از طریق آن، ورود و خروج کاربران انجام می‌شود.
\end{itemize}
\restoregeometry